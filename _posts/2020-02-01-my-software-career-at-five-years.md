---
layout: single
author_profile: false
title:  "My software career at five years"
date:   2020-02-01 21:17:08 -0500
categories: [tech]
---

This month marks my five-year anniversary of being a professional software developer, so I took some time to reflect on where I started and how I’m feeling now.

Since graduating from Dev Bootcamp¹ in January 2015, I’m on my third software development job. These jobs have been at three different companies. In my first job, I was coding in PHP and Javascript, and I used tools like Concrete5 and jQuery. I now code in Ruby, SQL, and Javascript, and I use tools like Ruby on Rails and React. My first two jobs were consultancies, and my current job is at a SAAS startup. My first job was entirely web-based, my second was both web and mobile, and my third is entirely web.

I’m thankful that I started out working in consultancies, because it taught me how to pace myself—when to deep dive into a problem versus when to move on to another task. It gave me a ton of practice at architecting projects from scratch. I also got many opportunities to experiment with shiny new tools and technologies.

I’m thankful that I now work at a startup with a single mission and product. Watching the product change and grow over time is fun and rewarding, and getting feedback from a mature user base really motivates me. I’ve also learned important lessons in scaling.

I’ve found that I don’t get as exhausted at the end of the day as I used to. Looking back on the very beginning, what I remember the most is just being tired all the time. I’m either more accustomed to this level of mental activity, or I’ve gotten better at avoiding mentally-draining pitfalls.

Related to this, I’ve also gotten better at defining what “quality” and “productivity” mean in this industry, which helps me pace myself for the endless sprint-marathon that is building software.

The software industry has relatively few universal standards for what makes a “good” or “productive” developer. Many developers will tell you that the meanings of these words depend entirely on what company you work at, what team you work with, or what product you’re working on. While this is liberating in many ways, it can make developers vulnerable to exploitation.

It’s easy to think you’re never going fast enough. Early-career developers are especially vulnerable to this. You equate more lines of code with more work. You’re reluctant to treat pure thinking as real and necessary work, because there’s seemingly nothing tangible to show from it. This is not entirely your fault. Early in your career, you tend to be judged more thoroughly on your raw output, and you’re not experienced enough to have your risks pay off. Whether it’s self-imposed or not, there’s a lot of “proving your worth” that needs to be done.

Ironically, believing I’m not productive enough has often caused me to be less productive. At five years I’ve gotten (mostly) past this psychological hurdle. I know more clearly where I stand in terms of my strengths and abilities. I don’t get as flustered by inscrutable error messages. I know when to quit at the end of the day. I’ve learned that slow is smooth, and smooth is fast. A lot of that is due to being in supportive work environments that allow me to focus on writing quality and maintainable code, which I’m grateful for.

I’ve learned that periodic reflection is necessary for breaking up the Assembly Line monotony of Kanban-style coding. Consistent team retrospectives have become a non-negotiable item for me, for any team I work with. A team that’s willing to talk to each other is a good team. Simple as that.

Writing has been a great tool for personal reflection. Lately I’ve been going long periods without writing a post, and I was worried this meant that I wasn’t learning enough new things. But I realized that the things I’ve lately found interesting and inspiring about code don’t fit neatly into short blog posts. So I’ll take this as a sign of progress.

I still have a lot of fundamental computer science concepts to learn. This past summer, I read a book about operating systems. While it didn’t have many direct benefits for my day-to-day work, I found that I was overall more confident in tackling harder problems. The most lasting insight from that book was that the problems I think are hard are actually hard. Caching is a universally hard problem. Scheduling is a universally hard problem. They have no single solution. In some weird way, knowing this is a relief.

I’m starting to forget what it was like to be new at coding. All this time cutting my teeth in a new profession, it didn’t occur to me that I’d actually have to deal with this one day. This is not a good thing. It’s a muscle I’m not using, and it makes me a less helpful team member. I know I can counteract this by finding a brand new programming language or tool to learn. This is a constant struggle for me, because I have a hard time coding for fun, even though I know it could greatly benefit my professional development. But after coding all week, it’s just not what I’d rather do with my free time. So I’m finding other ways to put myself into a beginner’s mindset again.

Overall I’m happy with the profession I chose and how it’s gone so far. I hope I’ll be writing another post like this at year ten.

---

*¹ The original coding bootcamp, now defunct*